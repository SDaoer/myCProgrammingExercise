# include <stdio.h>
# include <math.h>
# include <stdlib.h>

/* 在大于根号 N的整数中，不可能有连续的因子*/
/* 可证如下：
假设存在连续因子，m, m+1，其中 m>[sqrt(N)]，
对应有 x, y为 N的因子，满足 x*m=N, y*(m+1)=N
两式相乘可证得 x*y小于 1，与 “x, y为 N的因子”矛盾，原命题成立 */

/* 故而只会在小于等于 sqrt(N)+1 的范围产生连续因子
需要注意的是，大于等于 sqrt(N)+1 范围不会产生连续因子，
但 sqrt(N)+1 可能会作为其前面连续因子的最后一个，例如：
20：1、2、4、5、10、20
边界 sqrt(N)+1=5，作为前面连续因子的最后一个被算在内 */

/* 12! < 2**31 < 13! */

/* 是可能有削去前面几项，后面增加的更长的情况的
比如 1663200=5*6*7*8*9*10*11
1663200/2/3/4/5/6/7 是整数，但是
1663200/2/3/4/5/6/7/8 不是整数
就要舍弃前面的2、3、4，来获得 8、9、10、11以使得连续因子列更长 */


/***************做题中掉的巨坑*****************/
/* 不要忘了判断素数啊啊啊啊...... */
/* 前面 12! < 2**31 < 13! 这个纯属多余，反而容易引人误解......
因为知道最长能有多长毫无用处，并不能作为循环的边界。掉坑：一开始以为最长有 12 ，那么循环只要
 2 到 12 就可以了，实际上只要不超过 sqrt(N) 就可能会有连续因子，，可能前面 12 个数连续因子
长度只有 1 ，但后面会有别的连续因子，简单的反例：182 = 13*14 */
/* 发现上面这条之后，也就发现，判断素数完全不用单独拎出来，可以统一进找连续因子的循环里，没
找到连续因子，就说明是素数，打印数字本身就行了 */

int main()
{
    int N;
    scanf("%d", &N);

    int i;
    int loc=1, len=0;
    int begin=0, max_len=0;
    int temp = 1;
    int limit = (int)sqrt(N) + 1;

    for( i=2; i < limit; i++ ){
        // 向前拓展连续因子列
        temp *= i;
        len++;
        // 扩展后因子列不连续，调整重定位
        while( N % temp ){
            loc++;
            temp /= loc;
            len--;
        }
        // 记录当前最长连续因子列
        if( len > max_len ){
            begin = loc + 1;
            max_len = len;
        }
    }

    if( max_len ){
        printf("%d\n", max_len);
        for( i=0; i < max_len-1; i++ ){
            printf("%d*", begin+i);
        }
        printf("%d\n", begin+i);
    }else{
        printf("1\n%d\n", N);
    }

    system("pause");
    return 0;
}